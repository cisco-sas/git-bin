#!/bin/bash
BINSTORE_BASE=${BINSTORE_BASE:-}

if [ -z "$BINSTORE_BASE" ];
then
    echo "git-bin: no BINSTORE_BASE set. Please set this in your environment before trying again."
    exit 2
fi

remotename=`git remote -v | grep -E "origin.*push" | grep -oE "@([^ ]+)" | grep -oE "[:/][^ ]+" | sed 's/^[:\/]*//;s/\.git$//'`
binstore=$(dirname $BINSTORE_BASE/$remotename/blah) #using dirname with a fake file to clean up double slashes etc.

function file_is_not_binary {
    file -Li "$1" | grep -v binary 1>/dev/null 2>&1
    return $?
}

function verify_binstore {
    if [[ ! -d $binstore ]];
    then
        echo "git-bin: the binstore ($binstore) doesn't exist. You probably haven't added any binaries to git-bin yet. Creating it now"
        mkdir -p $binstore
        return 1
    fi
    ## TODO: verify that it is accessible, handle local caching?
}

function git-bin-add {
    local args=("${!1}")
    verify_binstore

    for src in "${args[@]}"
    do
        [[ $(basename "$src") == "." ]] && continue
        # if the file is a symlink, which doesn't point into the binstore (i.e.
        # it was a symlink originally), just add it. We do this before the 
        # check for directory, so that we don't traverse symlinked dirs.
        if [[ -L "$src" && `readlink "$src"` != "${binstore}*" ]]
        then
            git add $src
            continue
        fi

        if [[ -d "$src" ]]; 
        then
            echo "git-bin-add: descending into $src for recursive add."
            children=("$src"/*)
            git-bin-add children[@]
            continue
        fi

        # if the file is not a binary file, use regular git-add
        if file_is_not_binary "$src"
        then
            git add "$src"
            continue
        fi

        hash=`md5sum "$src" | cut -d" " -f1`

        # check whether the file is already a symlink to its hash in the binstore
        # i.e. there is nothing to reset
        [[ -L "$src" && "`readlink "$src"`" == "$binstore/$hash" ]] && continue 

        echo "git-bin-add: adding $src with hash $hash to $binstore"

        if [[ -e $binstore/$hash && `stat -c%s $binstore/$hash` != `stat -Lc%s "$src"` ]]; then
            echo "git-bin-add: SIGNATURE CONFLICT in $src!"
            echo "git-bin-add: $src in store has size `stat -c%s $binstore/$hash`, and your file has size `stat -Lc%s "$src"`"
            continue
        elif [[ -e $binstore/$hash && `stat -c%s $binstore/$hash` == `stat -c%s "$src"` ]]; then
            echo "git-bin-add: duplicate file $src, pointing at existing binstore copy."
            #TODO: symlink it anyways. There might be multiple 'copies' of the same file in a git repo.
            # drop the src file, symlink to the binstore:
            cp -f "$src" .tmp_$hash
            (rm -f "$src" && ln -s $binstore/$hash "$src" && git add "$src" && rm -f .tmp_$hash) || (echo "git-bin-add: something went wrong when adding $src, reverting" && mv -f .tmp_$hash $src)
            continue
        fi

        # BACKUP
        cp -f "$src" .tmp_$hash
        (cp -f "$src" $binstore/$hash && rm -f "$src" && ln -s $binstore/$hash "$src" && git add "$src" && rm -f .tmp_$hash) || (echo "git-bin-add: something went wrong when adding $src, HHHHH reverting" && mv -f .tmp_$hash "$src")
    done
}

# a function to add a file system. This isn't really necessary now that git-bin-add automatically detects non-binary files.
#function addfs { 
#    root="$1"
#    [[ "x$root" == "x" ]] && root="."
#
#    find $root -print0 | xargs -0 file | grep -v directory  > /tmp/gitbin_addfs_list
#    echo 'git-bin-addfs: `cat /tmp/gitbin_addfs_list | wc -l` files to be added'
#
#    echo 'git-bin-addfs: adding regular files'
#    cat /tmp/gitbin_addfs_list | grep -vE ":.*data|ELF|Compiled|GLS" | cut -d":" -f1 | sed 's/ /\\ /g' | xargs git add
#
#    echo 'git-bin-addfs: adding binary files'
#    cat /tmp/gitbin_addfs_list | grep -E ":.*data|ELF|Compiled|GLS" | cut -d":" -f1 | sed 's/ /\\ /g' | xargs git add
#}

function git-bin-edit {
    local args=("${!1}")
    verify_binstore || return # nothing to do if there isn't a binstore

    for src in "${args[@]}"
    do
        if [[ -d "$src" ]]; 
        then
            echo "git-bin-edit: recursive edits are disabled for your safety and sanity. Not descending into $src"
            continue
        fi
        storefile=`readlink "$src"`
        [[ $? == 1 || $(dirname "$storefile") != "$binstore" ]] && continue #not a symlink
        tmpfile=.tmp_$(basename "$storefile")

        cp "$storefile" "$tmpfile" && mv -f "$tmpfile" "$src" && echo "git-bin-edit: $src is now available for editing"
    done
}

function git-bin-reset {
    local args=("${!1}")
    verify_binstore || return # nothing to do if there isn't a binstore

    for src in "${args[@]}"
    do
        if [[ -d "$src" ]]; 
        then
            echo "git-bin-reset: recursive resets are disabled for your safety and sanity. Not descending into $src"
            continue
        fi

        gitstatus=`git status --porcelain "$src" |cut -c -2 | sed -e 's/ //g'`

        # if the file is not a binary file, use regular git-add
        if file_is_not_binary "$src"
        then
            case $gitstatus in
                "A")
                    # new file, just git reset it
                    git reset HEAD "$src"
                    ;;
                "M")
                    # file modified in index, need to checkout --
                    cp -f "$src" /tmp/$(basename "$src").justincase
                    git checkout -- "$src"
                    ;;
            esac
            continue
        fi

        hash=`md5sum "$src" | cut -d" " -f1`
     
        case $gitstatus in
            "A")
                # newly added file, not yet committed. need to copy the actual contents back and do a git reset HEAD
                # the file will be a symlink to it's contents.

                # check whether the file is already a symlink to its hash in the binstore
                [[ -L "$src" && `readlink "$src"` == "$binstore/$hash" ]] || (echo "git-bin-reset: something is horribly wrong with $src. It should be a symlink to it's contents, but isn't" && return)

                symtarget=`readlink "$src"`
                echo "git-bin-reset: unstaging $src"
                rm -f "$src" && cp -f "$symtarget" "$src" && git reset HEAD "$src"
                ;;
            "T")
                # editted file (type changed from symlink to real file). need to do git checkout -- 
                # the file is not a symlink to it's contents.
                # check whether the file is already a symlink to its hash in the binstore
                # i.e. there is nothing to reset
                [[ -L "$src" && `readlink "$src"` == "$binstore/$hash" ]] && continue 

                if [[ ! -e $binstore/$hash ]];
                then
                    # The hash is not in the binstore. this could be because the file was never tracked by
                    # git-bin, or because the file content has changed (following a git-bin-edit).
                    # We test to see if the file was in git-bin by seeing if git-status lists it as having
                    # had a type change (i.e. going from a symlink to a regular file). This will be the
                    # status even if the file has also had its contents changed. If this is not the case,
                    # we should just ignore the file as it's probably not a git-bin file.
                    git status "$src" | grep -E "typechange: $src\$" 2>&1 >/dev/null || continue
                    
                    #otherwise, the file has changed, so we should back it up!
                    echo "git-bin-reset: $src has changed, saving a copy to /tmp/$src.$hash"
                    cp -f "$src" /tmp/$(basename "$src").$hash
                else
                    # The has is in the binstore. We need to check for signature conflicts:
                    if [[ `stat -c%s $binstore/$hash` != `stat -c%s "$src"` ]]; then
                        echo "git-bin-reset: SIGNATURE CONFLICT in $src!"
                        echo "git-bin-reset: $src in store has size `stat -c%s $binstore/$hash`, and your file has size `stat -c%s $src`"
                        return
                    fi
                fi
                # now we can just restore the file using git.
                echo "git-bin-reset: restoring $src to the git HEAD"
                # we need a to checkout from head:
                rm -f "$src" && git checkout -- "$src"
                ;;
            "")
				# nothing to see here. move along.
				;;
            *)
                echo "unknown git status for file '$gitstatus' $src"
                ;;
        esac
    done
}

funcname=$1 ; shift
argv=("$@")

case $funcname in
    add|edit|reset) 
        if [[ -z "$1" ]];
        then
            echo "git-bin: you must specify a file name to operate on!"
            exit 1
        fi
        eval git-bin-${funcname} argv[@]
        ;;
    *) 
        echo "git-bin error: '$funcname' not a recognized command"
        echo "available commands are: add, edit, reset"
        ;;
esac
